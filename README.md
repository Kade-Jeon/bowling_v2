# 목적
볼링 점수 계산법이 2016년 커런트 프레임 스코어링(Current Frame Scoring)으로 바뀌면서 직관적이고 단순해졌다.
하지만 전통적인 계산 방식은 현재 프레임의 점수가 경우에 따라서 다음, 혹은 다다음 투구의 결과 값에 따라서 정해지기 때문에 복잡한 부분이 있다.
따라서 전통적인 점수 계산 방식을 코드로 구현해보면서 공부할 수 있는 기회라고 생각하여 진행하게 되었다.

# 볼링 점수 계산 방법
볼링은 한 프레임에 2번의 기회가 주어지고, 마지막 10프레임에서는 2번의 결과에 따라 3번째 기회가 부여될지 정해진다.
설명을 위해 프레임에서 얻는 첫 번째 기회는 `초구` 라고 표현하고 두 번째는 `스페어` 라고 하겠다.
`스페어 성공` 의 뜻은 초구 이후 남은 핀을 `스페어` 에서 모두 제거한 경우라고 하겠다. (`초구` + `스페어` = 10)
`스트라이크` 는 초구에 10개를 모두 쓰러뜨린 경우다. 이 경우에는 프레임이 종료된다.

각 프레임의 점수는 이전 프레임 점수 + 아래와 같이 계산된 해당 프레임의 점수의 합이다.

1. `스페어 실패`의 경우, 프레임 점수는 해당 프레임의 결과가 그대로 적용된다 => `초구` + `스페어`
2. `스페어 성공`의 경우, 프레임 점수는 다음 프레임의 초구 점수까지 합한 결과가 된다. => `초구` + `스페어` + `다음 초구`
3. `스트라이크`의 경우, 프레임 점수는 다음 프레임의 초구와 스페어 점수까지 합한 결과가 된다 => `스트라이크` + `다음 초구` + `다음 스페어`
4. `스트라이크`를 두 프레임 연속한 경우, 이를 `더블`이라고 표현하며 이 경우 결과는
    4-1. 첫 번째 `스트라이크`가 있던 프레임의 점수 => `첫 스트라이크` + `두 번째 스트라이크` + `세 번째 초구` + `세 번째 스페어`
    4-2. 두 번째 `스트라이크`가 있던 프레임의 점수는 3에 해당하여 계산됨
    4-3. 세 번째 프레임의 점수는 다시 1, 2에 해당하여 계산됨.
5. `스트라이크`를 세 프레임 연속한 경우, 이를 `터키`라고 표현하며 이 경우
    5-1. 첫 번째 `스트라이크`가 있던 프레임의 점수 => `첫 스트라이크` + `두 번째 스트라이크` + `세 번째 스트라이크`
    5-2. 두 번째 `스트라이크`가 있던 프레임의 점수는 `더블` 케이스에 해당하여 계산됨
    5-3. 세 번째 `스트라이크`가 있던 프레임의 점수는 `스트라이크` 케이스에 해당하여 계산됨
6. 마지막 10 프레임의 경우에는 `스트라이크` 또는 `스페어 성공`을 해야만 보너스 기회가 부여된다.

한 프레임에서 최대로 얻을 수 있는 점수는 30점이며, 10프레임 최대 점수는 300점이 만점이다.

# v1의 문제점
v1에서 문제가 많았고, 부족한 부분이 많았기 때문에 보완해서 진행하고자 했다.
v1에서 제기된 문제점은 아래와 같다.

1. 불필요 메서드 존재
2. 역할 분리 실패
3. 음수 값 처리 실패
4. 부분적 점수 로직 계산 오류

# 볼링 점수 계산 시스템 설계
이번에는 각 클래스 별로 역할을 주어 크게 세 개로 구분하고자 했다.

1. 입력 역할 (In) : `InputData.Class`
2. 출력 역할 (Out) : `Message.Class`
3. 게임 역할 (Business Logic) : `BowlingService.Class`
4. 플레이어 객체 : `Player.Class`
5. 커스텀 예외 : `InputOutOfRangeException`

## 1. 입력 역할 (In) : `InputData.Class`
- Scanner를 통해 입력 값을 받도록 하여 사용자로부터 입력받는 메서드는 모두 여기서 처리하도록 구현했다.
- Scanner를 통해 외부로부터 입력받는 값은 정수(Integer)만 받게 되어 있는데, 여기서 만약 문자열(String)이 들어오면 무한 루프가 돌게된다. 
  따라서 이를 해결하기 위해 cleanBuffer() 메서드를 이용해 버퍼를 비워준다.

## 2. 출력 역할 (Out) : `Message.Class`
- System.out.print()와 같이 콘솔로 내보내야하는 메서드는 모두 여기서 처리하도록 구현했다.
- 이 클래스의 경우, 여러 클래스에서 활용해야 하기 때문에 메서드들을 static으로 구현하여 중복으로 대입하는 것을 피했다.
- 콘솔에 필요한 부분을 컬러로 출력하기 위해 ANSI코드를 이용했다. 이를 활용해 경고는 빨간색으로 표현하고, Player 별로 고유의 컬러를 부여하여 데이터 입력 시, 명확하게 보이도록 구현했다.
- Business Logic에서 예외관련 메세지도 여기를 통해서 출력하도록 구현했다.(빨간색으로 표현)

## 3. 게임 역할 (Business Logic) : `BowlingService.Class`
게임 플레이와 직접적으로 관련이 있는 메서드는 모두 여기서 처리하도록 구현했다.
특히, 점수를 계산하는 socreCalculator() 메서드는 외부에서 호출할 필요가 없기 때문에 접근 제어자를 private로 하였다.

## 4. 플레이어 객체 : `Player.Class`
`Player.Class`는 name, scoreboard, totalScore를 갖고 게임에 참가하게 된다.
- name       : 플레이어 이름.
- scoreboard : 해당 프레임의 투구 결과.
  - X(스트라이크), /(스페어 성공), -(0 또는 Gutter)의 표기는 하지 않고 오로지 숫자로만 저장된다.
  - 전체는 크기가 10으로 고정이기 때문에 배열로 구현하여 불필요하게 크게 구현하여 메모리를 낭비할 필요가 없다고 생각했다.
  - 내부에 들어가는 값은 List<Integer>를 넣어 크기가 1, 2, 3으로 가변적인 상황에 대응할 수 있도록 했다. (기본 capacity는 2, 10 프레임은 3)
- totalScore : 해당 프레임의 점수 계산 결과.


## 5. 커스텀 예외 : `InputOutOfRangeException`
- `InputOutOfRangeException`은 `InputMismatchException`을 상속받아 구현된 커스텀 예외이며, 입력받아야 할 데이터의 범위가 넘어갔을 때,
에러 메세지를 띄워주기 위해 구현된 클래스이다. ex) 최대 플레이어 수 4명이 넘을 때, 스페어 값과 초구의 합이 10 초과하는 경우, 혹은 음수(-) 입력.
- `InputMismatchException` 은 입력 값이 문자열(String)인 경우 에러 메세지를 띄우는 용도로 활용했다.


# 아쉬운 부분
- 스페어 점수를 입력에 오류가 생겼을 때, 초구 결과부터 다시 입력받도록 되는 부분.
- 출력되는 점수판에서 계산 전 프레임 점수가 모두 0으로 표기되는 부분. (설계 실패)
  - totalScore를 String[]으로 구현했어야 했는데 int[]로 구현하는 바람에 공백 값을 넣을 수가 없게 됐다.
  - int[]라, 공백을 불가능하고 null을 넣는 것보다 0이 나을 것으로 판단했다.
  - 이미 90% 가까이 완성된 후, 발견한 부분이라 되돌리기엔 늦어서 아쉬운 부분으로 남겨두었다.
- 


